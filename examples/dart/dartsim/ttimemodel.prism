mdp
// init block must include values for the following constants
//const int HORIZON
//const double PERIOD
//const int MAX_ALT_LEVEL
//const int init_a
//const int init_f
//const double IncAlt_LATENCY
//const double DecAlt_LATENCY
//const int ini_IncAlt_state
//const int ini_DecAlt_state
//const double destructionFormationFactor
//const double threatRange
//const double detectionFormationFactor
//const double sensorRange

const double PERIOD = 60;
const int HORIZON = 5;
const double IncAlt_LATENCY = 60;
const double DecAlt_LATENCY = 60;
const int MAX_ALT_LEVEL = 3;
const double destructionFormationFactor = 1.5;
const double threatRange = 3;
const double detectionFormationFactor = 1.2;
const double sensorRange = 4;
const init_a = 3;
const init_f = 0;
const int ini_IncAlt_state = 0;
const int ini_DecAlt_state = 0;


//************************************************************************
// CLOCK
//************************************************************************
const int TO_TICK = 0;
const int TO_TICK2 = 1; // intermediate tick for constraint satisf. update
const int TO_TACK = 2;

label "final" = time = HORIZON & clockstep=TO_TICK;
formula sys_go = clockstep=TO_TICK;

module clk
    time : [0..HORIZON] init 0;
    clockstep : [0..2] init TO_TICK;

    [tick] clockstep=TO_TICK & time < HORIZON -> 1: (time'=time+1) & (clockstep'=TO_TICK2);
    [tick2] clockstep=TO_TICK2 -> 1 : (clockstep'=TO_TACK);
    [tack] clockstep=TO_TACK -> 1: (clockstep'=TO_TICK);
endmodule

module env
s : [0..45] init 0;
[tick] s = 0 -> 
	0.034225 : (s' = 1)
	+ 0.11655 : (s' = 2)
	+ 0.034225 : (s' = 3)
	+ 0.11655 : (s' = 4)
	+ 0.3969 : (s' = 5)
	+ 0.11655 : (s' = 6)
	+ 0.034225 : (s' = 7)
	+ 0.11655 : (s' = 8)
	+ 0.034225 : (s' = 9);
[tick] s = 1 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 2 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 3 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 4 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 5 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 6 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 7 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 8 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 9 -> 
	0.034225 : (s' = 10)
	+ 0.11655 : (s' = 11)
	+ 0.034225 : (s' = 12)
	+ 0.11655 : (s' = 13)
	+ 0.3969 : (s' = 14)
	+ 0.11655 : (s' = 15)
	+ 0.034225 : (s' = 16)
	+ 0.11655 : (s' = 17)
	+ 0.034225 : (s' = 18);
[tick] s = 10 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 11 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 12 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 13 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 14 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 15 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 16 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 17 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 18 -> 
	0.034225 : (s' = 19)
	+ 0.11655 : (s' = 20)
	+ 0.034225 : (s' = 21)
	+ 0.11655 : (s' = 22)
	+ 0.3969 : (s' = 23)
	+ 0.11655 : (s' = 24)
	+ 0.034225 : (s' = 25)
	+ 0.11655 : (s' = 26)
	+ 0.034225 : (s' = 27);
[tick] s = 19 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 20 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 21 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 22 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 23 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 24 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 25 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 26 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 27 -> 
	0.034225 : (s' = 28)
	+ 0.11655 : (s' = 29)
	+ 0.034225 : (s' = 30)
	+ 0.11655 : (s' = 31)
	+ 0.3969 : (s' = 32)
	+ 0.11655 : (s' = 33)
	+ 0.034225 : (s' = 34)
	+ 0.11655 : (s' = 35)
	+ 0.034225 : (s' = 36);
[tick] s = 28 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 29 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 30 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 31 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 32 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 33 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 34 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 35 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
[tick] s = 36 -> 
	0.034225 : (s' = 37)
	+ 0.11655 : (s' = 38)
	+ 0.034225 : (s' = 39)
	+ 0.11655 : (s' = 40)
	+ 0.3969 : (s' = 41)
	+ 0.11655 : (s' = 42)
	+ 0.034225 : (s' = 43)
	+ 0.11655 : (s' = 44)
	+ 0.034225 : (s' = 45);
endmodule

// environment has 2 components

formula stateValue = (s = 0 ? 0 : 0) + 
                     (s = 1 ? 0.0169524 : 0) + 
                     (s = 2 ? 0.0169524 : 0) + 
                     (s = 3 ? 0.0169524 : 0) + 
                     (s = 4 ? 0.206299 : 0) + 
                     (s = 5 ? 0.206299 : 0) + 
                     (s = 6 ? 0.206299 : 0) + 
                     (s = 7 ? 0.631597 : 0) + 
                     (s = 8 ? 0.631597 : 0) + 
                     (s = 9 ? 0.631597 : 0) + 
                     (s = 10 ? 0.368403 : 0) + 
                     (s = 11 ? 0.368403 : 0) + 
                     (s = 12 ? 0.368403 : 0) + 
                     (s = 13 ? 0.793701 : 0) + 
                     (s = 14 ? 0.793701 : 0) + 
                     (s = 15 ? 0.793701 : 0) + 
                     (s = 16 ? 0.983048 : 0) + 
                     (s = 17 ? 0.983048 : 0) + 
                     (s = 18 ? 0.983048 : 0) + 
                     (s = 19 ? 0 : 0) + 
                     (s = 20 ? 0 : 0) + 
                     (s = 21 ? 0 : 0) + 
                     (s = 22 ? 0 : 0) + 
                     (s = 23 ? 0 : 0) + 
                     (s = 24 ? 0 : 0) + 
                     (s = 25 ? 0 : 0) + 
                     (s = 26 ? 0 : 0) + 
                     (s = 27 ? 0 : 0) + 
                     (s = 28 ? 0.0169524 : 0) + 
                     (s = 29 ? 0.0169524 : 0) + 
                     (s = 30 ? 0.0169524 : 0) + 
                     (s = 31 ? 0.206299 : 0) + 
                     (s = 32 ? 0.206299 : 0) + 
                     (s = 33 ? 0.206299 : 0) + 
                     (s = 34 ? 0.631597 : 0) + 
                     (s = 35 ? 0.631597 : 0) + 
                     (s = 36 ? 0.631597 : 0) + 
                     (s = 37 ? 0 : 0) + 
                     (s = 38 ? 0 : 0) + 
                     (s = 39 ? 0 : 0) + 
                     (s = 40 ? 0 : 0) + 
                     (s = 41 ? 0 : 0) + 
                     (s = 42 ? 0 : 0) + 
                     (s = 43 ? 0 : 0) + 
                     (s = 44 ? 0 : 0) + 
                     (s = 45 ? 0 : 0);

formula stateValue1 = (s = 0 ? 0 : 0) + 
                     (s = 1 ? 0.0169524 : 0) + 
                     (s = 2 ? 0.206299 : 0) + 
                     (s = 3 ? 0.631597 : 0) + 
                     (s = 4 ? 0.0169524 : 0) + 
                     (s = 5 ? 0.206299 : 0) + 
                     (s = 6 ? 0.631597 : 0) + 
                     (s = 7 ? 0.0169524 : 0) + 
                     (s = 8 ? 0.206299 : 0) + 
                     (s = 9 ? 0.631597 : 0) + 
                     (s = 10 ? 0.13535 : 0) + 
                     (s = 11 ? 0.5 : 0) + 
                     (s = 12 ? 0.86465 : 0) + 
                     (s = 13 ? 0.13535 : 0) + 
                     (s = 14 ? 0.5 : 0) + 
                     (s = 15 ? 0.86465 : 0) + 
                     (s = 16 ? 0.13535 : 0) + 
                     (s = 17 ? 0.5 : 0) + 
                     (s = 18 ? 0.86465 : 0) + 
                     (s = 19 ? 0 : 0) + 
                     (s = 20 ? 0 : 0) + 
                     (s = 21 ? 0 : 0) + 
                     (s = 22 ? 0 : 0) + 
                     (s = 23 ? 0 : 0) + 
                     (s = 24 ? 0 : 0) + 
                     (s = 25 ? 0 : 0) + 
                     (s = 26 ? 0 : 0) + 
                     (s = 27 ? 0 : 0) + 
                     (s = 28 ? 0 : 0) + 
                     (s = 29 ? 0 : 0) + 
                     (s = 30 ? 0 : 0) + 
                     (s = 31 ? 0 : 0) + 
                     (s = 32 ? 0 : 0) + 
                     (s = 33 ? 0 : 0) + 
                     (s = 34 ? 0 : 0) + 
                     (s = 35 ? 0 : 0) + 
                     (s = 36 ? 0 : 0) + 
                     (s = 37 ? 0 : 0) + 
                     (s = 38 ? 0 : 0) + 
                     (s = 39 ? 0 : 0) + 
                     (s = 40 ? 0 : 0) + 
                     (s = 41 ? 0 : 0) + 
                     (s = 42 ? 0 : 0) + 
                     (s = 43 ? 0 : 0) + 
                     (s = 44 ? 0 : 0) + 
                     (s = 45 ? 0 : 0);


//************************************************************************
// SYSTEM
//************************************************************************

// Variable range and initialization
const a_MIN=0; const a_MAX=MAX_ALT_LEVEL; const a_INIT=init_a;
const f_MIN=0; const f_MAX=1; const f_INIT=init_f;

module sys
	a : [a_MIN..a_MAX] init a_INIT;
	f : [f_MIN..f_MAX] init f_INIT;
	
	[GoTight_start] f=0 -> 1: (a'=a_GoTight_impact)
		 &  (f'=f_GoTight_impact);
	[GoLoose_start] f=1 -> 1: (a'=a_GoLoose_impact)
		 &  (f'=f_GoLoose_impact);
	[IncAlt_complete] a < MAX_ALT_LEVEL -> 1:  (a'=a_IncAlt_impact)
	 	&  (f'=f_IncAlt_impact);
	[DecAlt_complete] a > 0 -> 1:  (a'=a_DecAlt_impact)
		 &  (f'=f_DecAlt_impact);
endmodule


formula a_GoTight_impact = a + (0) >= a_MIN ? ( a+(0)<=a_MAX?  a+(0) : a_MAX) : a_MIN;
formula f_GoTight_impact = f + (1) >= f_MIN ? ( f+(1)<=f_MAX?  f+(1) : f_MAX) : f_MIN;
formula a_GoLoose_impact = a + (0) >= a_MIN ? ( a+(0)<=a_MAX?  a+(0) : a_MAX) : a_MIN;
formula f_GoLoose_impact = f + (-1) >= f_MIN ? ( f+(-1)<=f_MAX?  f+(-1) : f_MAX) : f_MIN;
formula a_IncAlt_impact = a + (1) >= a_MIN ? ( a+(1)<=a_MAX?  a+(1) : a_MAX) : a_MIN;
formula f_IncAlt_impact = f + (0) >= f_MIN ? ( f+(0)<=f_MAX?  f+(0) : f_MAX) : f_MIN;
formula a_DecAlt_impact = a + (-1) >= a_MIN ? ( a+(-1)<=a_MAX?  a+(-1) : a_MAX) : a_MIN;
formula f_DecAlt_impact = f + (0) >= f_MIN ? ( f+(0)<=f_MAX?  f+(0) : f_MAX) : f_MIN;


// tactic concurrency rules
formula IncAlt_used = IncAlt_state != 0;
formula DecAlt_used = DecAlt_state != 0;

formula GoTight_compatible = !GoLoose_used;
formula GoLoose_compatible = !GoTight_used;
formula IncAlt_compatible = !DecAlt_used;
formula DecAlt_compatible = !IncAlt_used;

//************************************************************************
// TACTIC: GoTight
//************************************************************************

// Applicability conditions
formula GoTight_applicable = GoTight_compatible & f=0;

module GoTight
    GoTight_used : bool init false;
    GoTight_go : bool init true;

    // Tactic applicable, start it
    [GoTight_start] sys_go & GoTight_go & GoTight_applicable -> (GoTight_used'=true) & (GoTight_go'=false);

    // Tactic applicable, but do not start it
    [] sys_go & GoTight_go & GoTight_applicable -> (GoTight_go'=false);

    // Pass if the tactic is not applicable
    [] sys_go & GoTight_go & !GoTight_applicable -> 1 : (GoTight_go'=false);

    [tick] !GoTight_go -> 1: (GoTight_go'=true) & (GoTight_used'=false);
endmodule


//************************************************************************
// TACTIC: GoLoose
//************************************************************************

// Applicability conditions
formula GoLoose_applicable = GoLoose_compatible & f=1;

module GoLoose
    GoLoose_used : bool init false;
    GoLoose_go : bool init true;

    // Tactic applicable, start it
    [GoLoose_start] sys_go & GoLoose_go & GoLoose_applicable -> (GoLoose_used'=true) & (GoLoose_go'=false);

    // Tactic applicable, but do not start it
    [] sys_go & GoLoose_go & GoLoose_applicable -> (GoLoose_go'=false);

    // Pass if the tactic is not applicable
    [] sys_go & GoLoose_go & !GoLoose_applicable -> 1 : (GoLoose_go'=false);

    [tick] !GoLoose_go -> 1: (GoLoose_go'=true) & (GoLoose_used'=false);
endmodule


//************************************************************************
// TACTIC: IncAlt
//************************************************************************

const int IncAlt_LATENCY_PERIODS = ceil(IncAlt_LATENCY/PERIOD);

// Applicability conditions
formula IncAlt_applicable = IncAlt_compatible & a < MAX_ALT_LEVEL;

module IncAlt
    IncAlt_state : [0..IncAlt_LATENCY_PERIODS] init ini_IncAlt_state;
    IncAlt_go : bool init true;

    // Tactic applicable, start it
    [IncAlt_start] sys_go & IncAlt_go & IncAlt_state=0 & IncAlt_applicable -> (IncAlt_state'=IncAlt_LATENCY_PERIODS) & (IncAlt_go'=false);

    // Tactic applicable, but do not start it
    [] sys_go & IncAlt_go & IncAlt_state=0 & IncAlt_applicable -> (IncAlt_go'=false);

    // Pass if the tactic is not applicable
    [] sys_go & IncAlt_go & IncAlt_state=0 & !IncAlt_applicable -> 1 : (IncAlt_go'=false);

    // Progress of the tactic
    [] sys_go & IncAlt_go & IncAlt_state > 1 -> 1: (IncAlt_state'=IncAlt_state-1) & (IncAlt_go'=false);

    // Completion of the tactic
    [IncAlt_complete] sys_go & IncAlt_go & IncAlt_state=1 -> 1: (IncAlt_state'=0) & (IncAlt_go'=true);

    [tick] !IncAlt_go -> 1: (IncAlt_go'=true);
endmodule


//************************************************************************
// TACTIC: DecAlt
//************************************************************************

const int DecAlt_LATENCY_PERIODS = ceil(DecAlt_LATENCY/PERIOD);

// Applicability conditions
formula DecAlt_applicable = DecAlt_compatible & a > 0;

module DecAlt
    DecAlt_state : [0..DecAlt_LATENCY_PERIODS] init ini_DecAlt_state;
    DecAlt_go : bool init true;

    // Tactic applicable, start it
    [DecAlt_start] sys_go & DecAlt_go & DecAlt_state=0 & DecAlt_applicable -> (DecAlt_state'=DecAlt_LATENCY_PERIODS) & (DecAlt_go'=false);

    // Tactic applicable, but do not start it
    [] sys_go & DecAlt_go & DecAlt_state=0 & DecAlt_applicable -> (DecAlt_go'=false);

    // Pass if the tactic is not applicable
    [] sys_go & DecAlt_go & DecAlt_state=0 & !DecAlt_applicable -> 1 : (DecAlt_go'=false);

    // Progress of the tactic
    [] sys_go & DecAlt_go & DecAlt_state > 1 -> 1: (DecAlt_state'=DecAlt_state-1) & (DecAlt_go'=false);

    // Completion of the tactic
    [DecAlt_complete] sys_go & DecAlt_go & DecAlt_state=1 -> 1: (DecAlt_state'=0) & (DecAlt_go'=true);

    [tick] !DecAlt_go -> 1: (DecAlt_go'=true);
endmodule

//*******************************
// Utility Function
//*******************************
const int LOOSE = 0;
const int TIGHT = 1;

formula probOfThreat = stateValue;

formula probabilityOfDestruction = probOfThreat
	* ((f = LOOSE) ? 1.0 : (1.0 / destructionFormationFactor))
		* max(0.0, threatRange - (a + 1)) / threatRange; // +1 because level 0 is one level above ground

module constraint // in this case the constraint is surviving
	satisfied: bool init true;
	[tick2] satisfied -> (1.0 - probabilityOfDestruction): (satisfied'=true)
		+ probabilityOfDestruction: (satisfied'=false);
	[tick2] !satisfied -> true;
endmodule


formula probOfTarget= stateValue1;

formula probOfDetection = probOfTarget
	* ((f = LOOSE) ? 1.0 : (1.0 / detectionFormationFactor))
		* max(0.0, sensorRange - (a + 1)) / sensorRange; // +1 because level 0 is one level above ground

module sensor
	targetDetected: bool init false;
	[tick2] true -> probOfDetection: (targetDetected'=true) + (1.0 - probOfDetection): (targetDetected'=false);
endmodule

rewards "util"
	[tack] satisfied & targetDetected : 1;
	
	// give slight preference to not adapting
	[tick] time = 0 &  IncAlt_state=ini_IncAlt_state & DecAlt_state=ini_DecAlt_state & a=init_a & f=init_f : 0.000000001;
endrewards
